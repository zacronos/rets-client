// Generated by CoffeeScript 1.10.0

/* jshint node:true */


/* jshint -W097 */

(function() {
  'use strict';
  var errors, expat, getSimpleParser, getStreamParser, headersHelper, hex2a, replyCodes, through2;

  expat = require('node-expat');

  through2 = require('through2');

  errors = require('./errors');

  replyCodes = require('./replyCodes');

  hex2a = require('./hex2a');

  headersHelper = require('./headers');

  getSimpleParser = function(retsMethod, errCallback, headerInfo, parserEncoding) {
    var result;
    if (parserEncoding == null) {
      parserEncoding = 'UTF-8';
    }
    result = {
      currElementName: null,
      parser: new expat.Parser(parserEncoding),
      finish: function() {
        return result.parser.removeAllListeners();
      },
      status: null
    };
    result.parser.once('startElement', function(name, attrs) {
      if (name !== 'RETS') {
        result.finish();
        return errCallback(new errors.RetsProcessingError(retsMethod, 'Unexpected results. Please check the RETS URL.', headerInfo));
      }
    });
    result.parser.on('startElement', function(name, attrs) {
      result.currElementName = name;
      if (name !== 'RETS' && name !== 'RETS-STATUS') {
        return;
      }
      result.status = attrs;
      if (attrs.ReplyCode !== '0' && attrs.ReplyCode !== '20208') {
        result.finish();
        return errCallback(new errors.RetsReplyError(retsMethod, attrs.ReplyCode, attrs.ReplyText, headerInfo));
      }
    });
    result.parser.on('error', function(err) {
      result.finish();
      return errCallback(new errors.RetsProcessingError(retsMethod, "XML parsing error: " + (errors.getErrorMessage(err)), headerInfo));
    });
    result.parser.on('end', function() {
      result.finish();
      return errCallback(new errors.RetsProcessingError(retsMethod, "Unexpected end of xml stream.", headerInfo));
    });
    return result;
  };

  getStreamParser = function(retsMethod, metadataTag, rawData, parserEncoding) {
    var columnText, columns, currElementName, dataText, delimiter, fail, finish, headers, parser, processStatus, response, result, retsStream, writeOutput;
    if (parserEncoding == null) {
      parserEncoding = 'UTF-8';
    }
    if (metadataTag) {
      rawData = false;
      result = {
        rowsReceived: 0,
        entriesReceived: 0
      };
      delimiter = '\t';
    } else {
      result = {
        rowsReceived: 0,
        maxRowsExceeded: false
      };
      delimiter = null;
    }
    columnText = null;
    dataText = null;
    columns = null;
    currElementName = null;
    headers = null;
    parser = new expat.Parser(parserEncoding);
    retsStream = through2.obj();
    finish = function(type, payload) {
      parser.removeAllListeners();
      parser.on('error', function() {

        /* noop */
      });
      retsStream.write({
        type: type,
        payload: payload
      });
      return retsStream.end();
    };
    fail = function(err) {
      return finish('error', err);
    };
    writeOutput = function(type, payload) {
      return retsStream.write({
        type: type,
        payload: payload
      });
    };
    response = function(response) {
      headers = headersHelper.processHeaders(response.rawHeaders);
      return writeOutput('headerInfo', headers);
    };
    processStatus = function(attrs) {
      var status;
      if (attrs.ReplyCode !== '0' && attrs.ReplyCode !== '20208') {
        return fail(new errors.RetsReplyError(retsMethod, attrs.ReplyCode, attrs.ReplyText, headers));
      }
      status = {
        replyCode: attrs.ReplyCode,
        replyTag: replyCodes.tagMap[attrs.ReplyCode],
        replyText: attrs.ReplyText
      };
      return writeOutput('status', status);
    };
    parser.once('startElement', function(name, attrs) {
      if (name !== 'RETS') {
        return fail(new errors.RetsProcessingError(retsMethod, 'Unexpected results. Please check the RETS URL.', headers));
      }
      processStatus(attrs);
      return parser.on('startElement', function(name, attrs) {
        currElementName = name;
        switch (name) {
          case 'DATA':
            return dataText = '';
          case 'COLUMNS':
            return columnText = '';
          case metadataTag:
            writeOutput('metadataStart', attrs);
            return result.rowsReceived = 0;
          case 'COUNT':
            return writeOutput('count', parseInt(attrs.Records));
          case 'MAXROWS':
            return result.maxRowsExceeded = true;
          case 'DELIMITER':
            delimiter = hex2a(attrs.value);
            return writeOutput('delimiter', delimiter);
          case 'RETS-STATUS':
            return processStatus(attrs);
        }
      });
    });
    parser.on('text', function(text) {
      switch (currElementName) {
        case 'DATA':
          return dataText += text;
        case 'COLUMNS':
          return columnText += text;
      }
    });
    if (rawData) {
      parser.on('endElement', function(name) {
        currElementName = null;
        switch (name) {
          case 'DATA':
            writeOutput('data', dataText);
            return result.rowsReceived++;
          case 'COLUMNS':
            return writeOutput('columns', columnText);
          case 'RETS':
            return finish('done', result);
        }
      });
    } else {
      parser.on('endElement', function(name) {
        var data, i, model;
        currElementName = null;
        switch (name) {
          case 'DATA':
            if (!columns) {
              return fail(new errors.RetsProcessingError(retsMethod, 'Failed to parse columns', headers));
            }
            data = dataText.split(delimiter);
            model = {};
            i = 1;
            while (i < columns.length - 1) {
              model[columns[i]] = data[i];
              i++;
            }
            writeOutput('data', model);
            return result.rowsReceived++;
          case 'COLUMNS':
            if (!delimiter) {
              return fail(new errors.RetsProcessingError(retsMethod, 'Failed to parse delimiter', headers));
            }
            columns = columnText.split(delimiter);
            return writeOutput('columns', columns);
          case metadataTag:
            result.entriesReceived++;
            return writeOutput('metadataEnd', result.rowsReceived);
          case 'RETS':
            if (metadataTag) {
              delete result.rowsReceived;
            }
            return finish('done', result);
        }
      });
    }
    parser.on('error', function(err) {
      return fail(new errors.RetsProcessingError(retsMethod, "XML parsing error: " + (errors.getErrorMessage(err)), headers));
    });
    parser.on('end', function() {
      return fail(new errors.RetsProcessingError(retsMethod, "Unexpected end of xml stream.", headers));
    });
    return {
      parser: parser,
      fail: fail,
      retsStream: retsStream,
      response: response
    };
  };

  module.exports = {
    getSimpleParser: getSimpleParser,
    getStreamParser: getStreamParser
  };

}).call(this);
